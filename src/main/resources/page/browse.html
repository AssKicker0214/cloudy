<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link href="/static/webfonts/all.min.css" rel="stylesheet">
    <script src="/static/lib/vue.js"></script>
    <script src="/static/js/utils.js"></script>
    <script src="/static/js/watcher.js"></script>

    <script src="/static/component/file-list.js"></script>
    <link rel="stylesheet" href="/static/component/file-list.css">

    <script src="/static/component/arrow-nav.js"></script>
    <link rel="stylesheet" href="/static/component/arrow-nav.css">
</head>
<body>
<h1>vue</h1>
<main>
    <!--    <arrow-nav :path="path"></arrow-nav>-->
    <file-list :entries="entries"
               @enter-directory="enterDirectory"
               @download-file="downloadFile"
               @upload-file="uploadFile"
               @delete-file="deleteFile">

    </file-list>
</main>
<button onclick="next()">click</button>
<script>
    function next() {
        history.pushState(null, null, location.href + "/next")

    }

    const DATA_API_PREFIX = "/data-api/v1";
    const PAGE_ROUTE_PREFIX = "/page/browse";
    const main = new Vue({
        el: "main",
        data: {
            path: [],    // should all be directories
            entries: [],
        },
        methods: {
            refreshData() {
                console.log("refreshing data");
                let apiPath = DATA_API_PREFIX + "/" + this.path.join("/");
                return fetch(apiPath).then(res => {
                    if (res.ok && res.headers.get("Content-Type").toLowerCase() === "application/json") return res.json();
                }).then(j => {
                    if (!Array.isArray(j)) {
                        // response is not an array, discard
                        return;
                    }
                    this.entries = j;
                    console.log(j.map(x => JSON.stringify(x)).join("\n"));
                    return new Promise(resolve => resolve())
                })
            },
            enterDirectory(name) {
                if (name === ".." && this.path.length === 0) return;

                if (name === "..") {
                    this.path.pop();
                } else {
                    this.path.push(name);
                }
                this.refreshData().then(() => {
                    let state = `${PAGE_ROUTE_PREFIX}/${this.path.join('/')}`;
                    console.log("push state", state);
                    history.pushState(this.path, null, state);
                });
            },
            makeDataAPI(appender) {
                return (DATA_API_PREFIX + '/' + this.path.join('/') + '/' + appender).replace('//', '/');
            },
            downloadFile(name) {

            },
            deleteFile(name) {
                fetch(this.makeDataAPI(name), {
                    method: "DELETE"
                }).then(res => {
                    if (res.status === 204) console.log("deleted");
                    else if (res.status === 404) console.log("no such resource");
                    else console.log("delete error");
                })
            },
            uploadFile(files) {
                let file = files[0];
                let body = file.name;
                // if (file.size < Math.pow(2, 23)) {
                // let formData = new FormData();
                // formData.append("file", file, file.name);
                // body = formData
                // }
                fetch(DATA_API_PREFIX + this.path.map(p => '/' + p).join(""), {
                    method: 'POST',
                    headers: {
                        "Connection": "Keep-Alive"
                    },
                    body: body
                }).then(res => {
                    // conflict
                    // if (res.status === 409) return;
                    // else if (res.status === 201) {
                    console.log("file socket");
                    let ws = new WebSocket(`ws://${window.location.host}/upload`);
                    const blockSize = parseInt(res.headers.get("Max-Block-Size"));
                    ws.onopen = () => {
                        ws.send(this.path.map(p => p + "/") + file.name);
                    };
                    ws.onmessage = (evt) => {
                        let start = parseInt(evt.data);
                        let end = Math.min(file.size, start + blockSize);
                        if (end > start) {
                            console.log(start, end, end - start);
                            ws.send(file.slice(start, end))
                        } else {
                            ws.send("");
                            this.refreshData();
                        }
                        // }
                        // else return;
                    };
                });
            },
            created() {
                window.onpopstate = (evt) => {
                    this.path = evt.state;
                    this.refreshData();
                };
                history.pushState(this.path, null, window.location.href);
                this.path = parsePath();
                this.refreshData();
            }
        }
    });

    watcher.onmessage((msg) => {
        console.log(msg);
    });

    function parsePath() {
        let pathname = location.pathname;
        if (!pathname.startsWith(PAGE_ROUTE_PREFIX)) {
            console.error("unrecognized pathname");
            return;
        }
        let dataPath = pathname.substring(PAGE_ROUTE_PREFIX.length);
        return dataPath.split("/").filter(seg => seg !== "")
    }


</script>
</body>
</html>